
	使用hook要确保函数名是首字母大写开头
								useState	
	

1	const [fileList,setfileList] = useState([])   设置一个空数组       
2	const [id,setId] = useState('')   设置一个空字符串

	[count, setCount] = useState(0)拥有 2个参数 ，第一个参数是变量  第二个参数是修改第一个参数的方法，
	同时也可以在一个组件中多次使用 State Hook,例如 const [age, setAge] = useState(42);
	
	如果被更新的 state 需要基于之前的 state，采用函数式形式
	
	如果被更新的 state 为重置，采用普通形式，因为它总是把 count 设置回初始值

	可以用函数式的 setState 结合展开运算符来达到合并更新对象的效果。

	setState(prevState => {
  		// 也可以使用 Object.assign
 		 return {...prevState, ...updatedValues};
		});
	惰性初始 state
	initialState 参数只会在组件的初始渲染中起作用，后续渲染时会被忽略。
		const [state, setState] = useState(() => {
  			const initialState = someExpensiveComputation(props);
  			return initialState;
		});



								useEffect 

 useEffect Hook 可以看做 componentDidMount，componentDidUpdate 和 componentWillUnmount 这三个函数的组合。
	useEffect(fn1,[]} 它接受2个参数  
	第一个函数可以看做是componentDidMount，componentDidUpdate钩子的执行体，
	第二个参数是数组，表示监听的值改变后才会再次执行
	其中第一个函数的返回值代表componentWillUnmount钩子的执行体
	第二个参数为[]的时候，默认第一个函数是componentDidMount,只执行一次
	useEffect(() => {
  	document.title = `You clicked ${count} times`;
	}, [count]); // 仅在 count 更改时更新
	
	useEffect也可以按照功能写多个，会按照书写顺序依次执行
							useContext

	创建一个上下文
	const MyContext=React.createContext({theme:"red",toggle:()=>{}})
  	接收上下文
	const value = useContext(MyContext);
	接收一个 context 对象（React.createContext 的返回值）并返回该 context 的当前值。

	当前的 context 值由上层组件中距离当前组件最近的 <MyContext.Provider> 的 value prop 决定。

	useContext 的参数必须是 context 对象本身



								额外的Hook
							
								useReducer

	const [state, dispatch] = useReducer(reducer, initialArg, init);

	它接收一个形如 (state, action) => newState 的 reducer，并返回当前的 state 以及与其配套的 dispatch 方法

	useReducer的参数可以写到函数体外面 应该也可以直接从外部引入。
	参数配置：reducer： ruducer函数
		 initialArg, 初始化数组
		 init  ，惰性地创建初始 state，① 可以用于重置  ②可以将用于计算 state 的逻辑提取到 reducer 外部
 


								useCallback
								
	缓存一个函数
	const memoizedCallback = useCallback(
 		() => {
    			doSomething(a, b);
 			 },[a, b]);
	
	useCallback(fn, deps) 相当于 useMemo(() => fn, deps)。

	useCallback应该相当于监听回调
	
								useMemo	

	缓存一个值
	const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
	
	你可以把 useMemo 作为性能优化的手段，但不要把它当成语义上的保证。


								useRef

	const refContainer = useRef(initialValue);
		
	在函数组件中创建ref

								useImperativeHandle

	useImperativeHandle(ref, createHandle, [deps])

	useImperativeHandle 可以让你在使用 ref 时自定义暴露给父组件的实例值。在大多数情况下，应当避免使用 ref 这样的命令式代码。

	useRef可以在函数中缓存一个值

	
								useLayoutEffect


	其函数签名与 useEffect 相同，但它会在所有的 DOM 变更之后同步调用 effect。可以使用它来读取 DOM 布局并同步触发重渲染。
	
	在浏览器执行绘制之前，useLayoutEffect 内部的更新计划将被同步刷新。

	们推荐你一开始先用 useEffect，只有当它出问题的时候再尝试使用 useLayoutEffect。

	
								useDebugValue

	useDebugValue 可用于在 React 开发者工具中显示自定义 hook 的标签。


								hook规则



	只在最顶层使用 Hook             ----------不要在循环，条件或嵌套函数中调用 Hook


	只在 React 函数中调用 Hook 	----------不要在普通的 JavaScript 函数中调用 Hook


	ESLint 插件








								继续理解（踩坑）

1>      state hook : set同一变量的话不重新render
	
	在使用useState的第二个参数为函数时，如果返回的还是之前定义的变量，那么将不重新render

	eg：const [list,setList] =useState([])	 setList(() =>{/*这里是对list的操作*/  return  list}）这样就不重新render 

	解决： 需要将list克隆一份，返回新的变量 （例入let arr =[...list] return arr）
	


2>    useContext在创建上下文的时候是在函数外面的，const MyContext=React.createContext({theme:"red",toggle:()=>{}})，

	如果写到函数里面，子组件获取值的时候，const value = useContext(MyContext);会报错
	

3>     useReducer的时候在runder中写逻辑 要注意  swich中需要返回state值 ， 而不是直接break


4>      react中写函数组件，文件名开头最好大写 方便自动生成规范的rfc模板

5>  	useMemo使用场景是在父组件的一个state发生变化，子组件会调用所有的方法，所以在子组件中通过usememo来针对特定的值来进行调用


	并且格式是useMemo(()=>{getx1(name)},[name])， 不可以写成 useMemo(getx2(name2),[name2])，它的第一个参数的一个回调函数


6>      使用useState时候，使用push，pop，splice等直接更改数组对象的坑，demo中使用push直接更改数组无法获取到新值，


	应该采用析构方式，但是在class里面不会有这个问题。(这个的原因是push，pop，splice是直接修改原数组，react会认为state并没有发生变化，无法更新)


<7> 	useCallback的骚操作是因为可以接收参数 那么监听那里可以直接写空数组 函数内需要的变量全部传参就行 


	这样函数就始终只缓存了一次 父组件改状态，该函数也不会重新声明
